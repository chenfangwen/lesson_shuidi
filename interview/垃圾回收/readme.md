js产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。


- 如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，与此同时，还有一个 记录当前执行状态的指针（称为 ESP）
- 执行完showname,那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。
- 当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。

## 函数执行栈被覆盖消除，那么里面栈保存的变量则就被清除， 但是还有引用的堆空间里的变量还未清除

## 堆中的数据是如何回收的
- 要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。
- 代际假说
    在 V8 中会把堆分为新生代和老生代两个区域，**新生代**中存放的是生存时间短的对象，**老生代**中存放的生存时间久的对象。
    - 新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

    - 副垃圾回收器，主要负责新生代的垃圾回收。
    - 主垃圾回收器，主要负责老生代的垃圾回收。
## 垃圾回收器的工作流程
第一步是**标记**空间中活动对象和非活动对象。活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。

第二步是**回收**非活动对象所占据的内存。 其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

第三步是做**内存整理**。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。



## 主垃圾回收器
   标记 - 清除（Mark-Sweep）算法
- 首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。
- 接下来就是垃圾的清除过程，清除掉标记的垃圾数据的过程

  缺点：对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存

    标记 - 整理（Mark-Compact）算法 
- 这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，

## 思考 处理全停顿
由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做**全停顿**（Stop-The-World）。

V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的**子标记过程**，同时让垃圾回收标记和 JavaScript 应用逻辑**交替进行**，直到标记阶段完成，我们把这个算法称为**增量标记（Incremental Marking）算法**。如下图所示：


使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。