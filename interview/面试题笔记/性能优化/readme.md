                                     Web性能优化

1、避免坏请求

有时候页面中的html或css会向服务器请求一个不存在的资源，比如图片或者html文件，这会造成浏览器与服务器之间过多的往返请求。
 
2、避免css@import

使用@import方法引用css文件可能会带来一些影响页面加载速度的问题。比如导致文件按顺序加载（一个加载完成后才会加载另一个），无法并行加载；

就替换为：<link….>

3、避免使用document.write

在js中，可以使用document.write。在网页上显示内容或者调用外部资源，而通过此方法，浏览器采取一些多余的步骤（下载资源，读取资源）。运行js来了解需要做什么，调用其他资源时，需要重新在执行一次这个过程。由于浏览器之前不知道要显示什么，所以会降低页面加载的速度。

要知道，任何能够被document.write调用的资源，都可以通过html调用。这样速度会更快

document.write('<scriptsrc="another.js"></script>');

改为

<scriptsrc="another.js"></script>
 

4、合并多个外部css文件

网站中每使用一个css文件，都会让你的页面加载速度慢一点。可以css delivery工具，来检测页面代码中css文件。然后通过复制粘贴合并成一个。
 
5、合并多个外部js文件

可以用resource check来检测页面中所引用的js文件数，然后可以通过复制粘贴的方法将多个文件合并成一个。

6、通过css sprites来整合图像**雪碧图**

若页面中有6个小图像，那么浏览器在显示时会分别下载，你可以通过css sprites将这些图像合并成为一个，可以减少页面加载所需要的时间。
Css sprites两个步骤：整合图像，定位图像

7、延迟js加载

浏览器在执行js代码时，会停止处理页面。当页面中很多js文件或者代码要加载时，将导致严重的延迟。尽管可以使用defer，异步或将js代码放自页面底部来延迟js的加载。但这些都不是一个好的解决方案。

好方法
<script>
function downloadJSAtOnload(){
      var element=document.createElement("script");
      element.src="defer.js";
      document.body.appendChild(element);
}
if(window.addEventListener){
      window.addEventListener('load',downloadJSAtOnload,false);
}else if(window.attachEvent){
      window.attachEvent('onload',downloadJSAtOnload);
}else{
      window.οnlοad=downloadJSAtOnload;
}
</script>

8、启用压缩/Gzip

使用gzip对html和css文件进行压缩，通常可以大约节省50%到70%，这样加载页面只需要更少的带宽和更少的时间。

9、如果你的css和js较小，可以将css和js内嵌到html页面中，这样可以减少页面加载所需要的文件数，从而加快页面的加载。

10、用minify css压缩css代码
 

11、尽量减少dns查询次数

当浏览器和服务器建立链接时，它需要进行dns解析，将域名解析为ip地址，然而，一旦客户端需要执行dns lookup时，等待时间将会取决于域名服务器的有效响应速度。

虽然所有的isp的dns服务器都能缓存域名和ip地址映射表。但如果缓存的dns记录过期了而需要更新，则可能需要遍历多个dns节点，有时候需要通过全球范围内来找到可信任的域名服务器，一旦域名服务器工作繁忙，请求解析时，就需要排队则进一步延时等待时间。

所有减少dns查询次数很重要，页面加载就尽量避免额外耗时，为了减少dns查询次数，最好的解决方法就是在页面中减少不同的域名请求的机会、

可通过request checker工具来检测页面中存在多少请求后，进行优化。


12、尽量减少重定向

有时候为了特定需求，需要在网页中使用重定向。重定向的意思是，用户的原始请求（如请求A）被重定向到其他的请求（如请求B）；
网页中使用重定向会造成网站性能和速度下降，因为浏览器访问网址是一连串的过程，如果访问到一半，而跳转到新的地址，就会重复发起一连串的过程，这将浪费很多时间。所有我们尽量避免重定向。Google建议
A、       不要链接到一个包含重定向的页面
B、       不要请求包含重定向的资源


13、优化样式表和脚本顺序

Style标签和样式表调用代码应该放置在js代码的前面，这样可以使页面的加载速度加快。

14、避免js阻塞渲染

浏览器在遇到一个引入外部js文件的<script>标签时，会停下所有工作下载并解析执行它。在这个过程中，页面渲染和用户交互完全被阻塞了。这是页面加载就会停止。

谷歌建议删除干扰页面第一屏内容加载 的js，第一屏指的是用户在屏幕中最初看到的页面，无论桌面浏览器，还是手机

 

15、指定图像尺寸

当浏览器加载页面的html时，有时候需要在图片下载完成前，对页面布局进行定位。如果hmtl里的图片没有指定尺寸，或者代码描述的尺寸和实际的图片尺寸不符合时，浏览器需要在图片下载完成后在回溯到该图片，并重新显示，这将消耗额外的时间。

一、webpack打包文件体积过大？（最终打包为一个js文件）
	1.异步加载模块
	2.提取第三库 ，等公共代码
    optimization: {
        splitChunks: {
        cacheGroups: {
            commons: {
            name: 'commons',
            chunks: 'all',  //同步和异步引入
            minChunks: 2, //引入次数大于2
            minSize: 0 //只要映入了
            }
        }
        }
    },
	3.代码压缩 用plugin
	4.去除不必要的插件

如何优化webpack构建的性能
	一、减少代码体积 
            1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积
			2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理
			3.对一些组件库采用按需加载，避免无用的代码
	二、减少目录检索范围
			·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度
		
	三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias


二、我们把开发中的所有资源（图片，js、css文件）都看成模块，通过loader和plugins来对资源进行处理，打包成符合生产环节部署的前端资源。
							
三、移动端的性能优化
      1、首屏加载和按需加载，懒加载
      2、资源预加载
      3、图片压缩处理，使用base64内嵌图片
      4、合理缓存dom对象
      5、使用touchstart代替click（click 300毫秒的延迟）
      6、利用transform:translateZ(0)，开启硬件GUP加速
      7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明
      8、使用viewport固定屏幕渲染，加速页面渲染内容
      9、尽量使用事件代理，避免直接事件绑定

四、Vue的SPA 如何优化加载速度
	1.减少入口文件体积
	2.静态资源本地缓存
	3.开启Gzip压缩
	4.使用SSR,nuxt.js ,next.js

五、移动端300ms延迟
	由来：300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。
	     由于用户可以双击缩放或者是滚动的操作，当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作
	    因次，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕
	解决方案：1.禁用缩放，设置meta标签 user-scalable=no
		  2.fastclick.js
			原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即
			      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉
	fastclick.js还可以解决穿透问题

六、页面的重构；在不改变外部行为的前提下，简化结构、添加可读性


七、 loader和plugin区别
- Loader：用于对模块源码的转换，loader描述了webpack如何处理非javascript模块，并且在buld中引入这些依赖。loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。
- Plugin：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。

八、 js优化   https://www.cnblogs.com/fullhouse/archive/2012/01/05/2312956.html

1.[顶]关于JS的循环，循环是一种常用的流程控制。JS提供了三种循环：for(;;)、while()、for(in)。在这三种循环中 for(in)的效率最差，因为它需要查询Hash键，因此应尽量少用for(in)循环，for(;;)、while()循环的性能基本持平。当然，推 荐使用for循环，如果循环变量递增或递减，不要单独对循环变量赋值，而应该使用嵌套的++或－－运算符。

2.如果需要遍历数组，应该先缓存数组长度，将数组长度放入局部变量中，避免多次查询数组长度。

3.局部变量的访问速度要比全局变量的访问速度更快，因为全局变量其实是window对象的成员，而局部变量是放在函数的栈里的。

4.尽量少使用eval，每次使用eval需要消耗大量时间，这时候使用JS所支持的闭包可以实现函数模板。

5.尽量避免对象的嵌套查询，对于obj1.obj2.obj3.obj4这个语句，需要进行至少3次查询操作，先检查obj1中是否包含 obj2，再检查obj2中是否包含obj3，然后检查obj3中是否包含obj4...这不是一个好策略。应该尽量利用局部变量，将obj4以局部变量 保存，从而避免嵌套查询。

6.使运算符时，尽量使用+＝，－＝、*＝、\=等运算符号，而不是直接进行赋值运算。

7.[顶]当需要将数字转换成字符时，采用如下方式："" + 1。从性能上来看，将数字转换成字符时，有如下公式：("" +) > String() > .toString() > new String()。String()属于内部函数，所以速度很快。而.toString()要查询原型中的函数，所以速度逊色一些，new String()需要重新创建一个字符串对象，速度最慢。

8.[顶]当需要将浮点数转换成整型时，应该使用Math.floor()或者Math.round()。而不是使用parseInt(),该方法用于将字符串转换成数字。而且Math是内部对象，所以Math.floor()其实并没有多少查询方法和调用时间，速度是最快的。

9.尽量作用JSON格式来创建对象，而不是var obj=new Object()方法。因为前者是直接复制，而后者需要调用构造器，因而前者的性能更好。

10.当需要使用数组时，也尽量使用JSON格式的语法，即直接使用如下语法定义数组：[parrm,param,param...],而不是采用 new Array(parrm,param,param...)这种语法。因为使用JSON格式的语法是引擎直接解释的。而后者则需要调用Array的构造器。

11.[顶]对字符串进行循环操作，例如替换、查找，就使用正则表达式。因为JS的循环速度比较慢，而正则表达式的操作是用C写成的API，性能比较好。

最后有一个基本原则，对于大的JS对象，因为创建时时间和空间的开销都比较大，因此应该尽量考虑采用缓存。
