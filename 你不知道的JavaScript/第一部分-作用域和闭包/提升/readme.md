# 提升

- 先有鸡还是先有蛋
  直觉上可能会认为JavaScript代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确，有一种特殊的情况会导致这个假设是错误的  

  举个栗子：
  ```
  a = 2;

  var a;

  console.log(a);
  ```
  输出结果是 2

- 提升  

  上一个代码段中会被以如下的形式进行处理：
  ```
  var a;

  a = 2;

  console.log(a);
  ```
  其中第一部分是编译，而第二个部分是执行  

  这个过程就好像变量和函数声明从它们在代码中出现的位置被"移动"到了最上面。`这个过程就叫做提升`  

  实质：将变量和函数声明提前  

  `只有声明本身会被提升，而赋值或其他运行逻辑会被留在原地`  
  
  `函数声明会被提升，函数但是函数表达式却不会被提升`  

  举个栗子：
  ```
  foo(); // 不是ReferenceError，而是TypeError！

  var foo = function bar() {
      // ...
  };
  ```
  - foo()声明被提升并分配给所在作用域(在这里是全局作用域)，因此foo()不会导致 ReferenceError
  - 但是此时oo并没有赋值(如果它是一个函数声明而不是函数表达式，那么就会赋值)
  - foo由于对undefined值进行函数调用而导致非法操作，因此抛出TypeError异常

- 函数优先  

  函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量  

  举个栗子：
  ```
  foo(); // 1

  var foo;

  function foo() {
      console.log(1);
  };

  foo = function() {
      console.log(2);
  };
  ```
  会输出1而不是2！这个代码片段会被引擎理解为如下形式：
  ```
  function foo() {
      console.log(1);
  };

  foo(); // 1

  foo = function() {
      console.log(2);
  };
  ```
  ps：var foo尽管出现在function foo()...的声明之前，但它是重复的声明(因为被忽略)，因为函数声明会被提升到普通变量之前  

  尽管重复的var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的  
  
  举个栗子：
  ```
  foo(); // 3

  function foo() {
      console.log(1);
  };

  var foo = function() {
      console.log(2);
  };

  function foo() {
      console.log(3);
  }
  ```

-------------------------------------------
# 补充  
  代码的运行分为编译和执行两个部分  
  let 和 const 没有变量提升，只有 var 声明的变量才有提升，变量提升只是引擎在编译阶段做的事情，代码的实际位置不变  
  关于同名变量和函数的两点处理原则：  
  1. 如果是同名的函数，JavaScript 编译阶段会选择最后声明的那个  
  2. 如果变量和函数同名，那么在编译阶段，变量的声明会被忽略  
  > 输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。  
    执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。

- JavaScript 代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要先编译。  
  
  在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为 undefined；  
  
  在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数。  
  
  如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。