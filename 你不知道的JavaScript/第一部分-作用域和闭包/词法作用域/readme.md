# 词法作用域

- 词法作用域 (写代码时词法字面的作用域)  

  简单来说，词法作用域就是定义在此法阶段的作用域。  

  词法作用域是由你在写代码时将变量和块作用域写在哪里决定的

- 作用域嵌套  

  可以把每个作用域看成一个作用域气泡(所有的气泡最后都嵌套在全局气泡中)
  - 变量的查找(查找标识符)
    1. 在嵌套作用域中引擎会从嵌套的最里层向外查找，作用域会在查找到第一个匹配的标识符时停止
    2. 在多层的嵌套作用域中可以定义同名的标识符，这叫做"遮蔽效应"(内部的标识符"遮蔽"了外部的标识符)
    3. 非全局的变量被遮蔽之后，无论如何都无法被访问到
    4. 全局变量会自动成为全局对象的属性    

  `无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时候所处的位置决定`

- 欺骗词法
  - eval  

    eval(...) 函数可以接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中的这个位置的代码  

    就好像你自己写代码时就是写在那个位置的一样  

    举个栗子:
    ```
    function foo(str, a) {
        eval(str); // 欺骗 仿佛 var b = 3 就写在这个位置
        console.log(a, b);
    }
    var b = 2;
    foo("var b = 3", 1); // 1, 3
    ```
    代码 var b = 3 找到b后就不再继续向外查找
  - with  

    with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身  

    举个栗子：
    ```
    var obj = {
        a: 1,
        b: 2,
        c: 3
    };

    // 单调乏味的重复 obj
    obj.a = 2;
    obj.b = 3;
    obj.c = 4;

    // 简答的快捷方式
    with (obj) {
        a = 3;
        b = 4;
        c = 5;
    }
    ```

# 小结
  - JavaScript中有两个机制可以欺骗词法作用域：eval(...)和with
  - 前者可以对一段包含一个或多个声明的"代码"字符串进行演算，并借此来修改已经存在的词法作用域(在运行时)
  - 后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)
  - 副作用：  

    引擎无法再编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的  
    
    使用这其中任何一个机制都将导致代码运行变慢，不要使用他们    