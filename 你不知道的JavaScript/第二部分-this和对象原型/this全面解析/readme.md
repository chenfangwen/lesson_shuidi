# this全面解析  

- 调用位置  

  调用位置就是函数在代码中被调用的位置(而不是声明的位置)   

  最重要的时要分析调用栈(就是当前为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中。  

  例子 --- p82  

- 绑定规则  

  - 默认绑定  

    最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则  
    ```
    function foo() {
        console.log(this.a)
    }

    var a = 2;

    foo(); // 2
    ```
    声明在全局作用域中的变量就是全局对象的一个同名属性  

    当调用foo()时，this.a被解析成了全局变量a是因为应用了默认绑定。foo()是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。  

    ps：如果使用严格模式，则不能将全局对象用于默认绑定，因此this会绑定到undefined(在严格模式下调用foo()则不影响默认绑定)  

  - 隐式绑定  

    另一条需要考虑的规则时调用位置是否有上下文对象，或者说是否被某个对象拥有或包含。  
    ```
    function foo() {
        console.log(this.a);
    }

    var obj = {
        a: 2,
        foo: foo
    };

    obj.foo() // 2
    ```
    (无论是直接在obj中定义还是先定义再添加为引用属性，这个函数严格来说都不属于obj对象)  

    调用位置会使用obj上下文来引用函数，因此可以说函数被调用时obj对象"拥有"或者"包含"函数引用。当函数拥有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象  

    对象属性引用链中只有上一层或者说最后一层再调用位置中起作用。  

    举个栗子：
    ```
    function foo() {
        console.log(this.a);
    }

    var obj2 = {
        a: 42,
        foo: foo
    };

    var obj1 = {
        a: 2,
        obj2: obj2
    };

    obj1.obj2.foo(); // 42
    ```
    - 隐式丢失  

      一个常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就说它会应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式  
      举个栗子： 
      ```
      function foo() {
          console.log(this.a);
      }

      var obj = {
          a: 2,
          foo: foo
      };

      var bar = obj.foo(); // 函数别名!

      var a = "oops, global";

      bar(); // "oops, global"
      ```
      虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定  

      还有一种情况是回调函数：  
      ```
      function foo() {
          console.log(this.a);
      }

      function foFoo(fn) {
          // fn 其实引用的是foo

          fn(); // <-- 调用位置!
      }

      var obj = {
          a: 2,
          foo: foo
      };

      var a = "oops, global";

      doFoo(obj.foo); // "oops, global"
      ```
      参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样  

  - 显式绑定  
    
    使用apply、call、bind --- p88-90

  - new绑定  

    使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：  

    1. 创建(或者说构造)一个全新的对象  

    2. 这个新对象会被执行[[prototype]]连接  

    3. 这个新对象会被绑定到函数调用的this  

    4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象  


- 优先级  

  默认 < 隐式 < 显示 < new

- 判断this  

  1. 函数是都再new中调用(new绑定)？如果是的话this绑定的时新创建的对象  
     var bar = new foo();  

  2. 函数是否通过call、apply(显示绑定)或者硬绑定调用？如果是的话，this绑定的是执行的对象  
     var bar = foo.call(obj)  

  3. 函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this绑定的是那个上下文对象  
     var bar = obj1.foo()  

  4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象  
     var bar = foo()  

- 绑定例外  

  - 被忽略的this  

    如果把nulll或undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则  

    例子 --- p96  

  - 间接引用  

    你可能有意或无意地创建一个函数的"间接引用"，在这种情况下，调用函数会应用默认的绑定规则  

  - 软绑定  
    
    解决硬绑定之后无法使用隐式绑定或是显式绑定来修改this --- p98  

- this词法  

  箭头函数不使用this的四种标准规则，而是根据外层(函数或者全局)作用域来决定和this  

  箭头函数的绑定无法被修改(new也不行)  

  